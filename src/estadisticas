#!/usr/bin/python3

import time
import multiprocessing
import multiprocessing.pool
import pandas as pd
import matplotlib.pylab as plt
import matplotlib as mpl
import numpy as np
import os
import pprint
import gc
import re


#funciones

def sorted_nicely( l ):
    """ Sorts the given iterable in the way that is expected.

    Required arguments:
    l -- The iterable to be sorted.

    """
    convert = lambda text: int(text) if text.isdigit() else text
    alphanum_key = lambda key: [convert(c) for c in re.split('([0-9]+)', key)]
    return sorted(l, key = alphanum_key)

def leer_columnas(f):
    archivo = open(f)
    nombre_columnas = archivo.readline().split(',')

    archivo.close()
    return True

def cargarDatos():

    loadDictCompleto('fran_general')

    return

def buscar_string(archivo, palabra):

    linea = None
    for i in archivo:
        if i.startswith(palabra):
            linea = i
            break
    if linea == None:
        return ''
    else:
        return linea.split('=')[1].strip(' \n\t\r')

def buscar_valor(archivo, palabra):

    linea = 'FALLO'
    for i in archivo:
        if i.startswith(palabra):
            linea = i
            break
    if linea == 'FALLO':
        return 0
    else:
        print(linea.split('=')[1])
        print(float(linea.split('=')[1]))
        return float(linea.split('=')[1])

def buscar_y_acumular(archivo, inicio, fin, palabra):
    reads = 0
    for linea in archivo:
        if linea.startswith(inicio):
            break
    for linea in archivo:
        if linea.startswith(palabra+' ='):
            reads = reads + float(linea.split('=')[1])
        elif linea.startswith(fin):
            break
    return reads

def buscar_y_acumular_porcentage(archivo, inicio, fin, palabra):
    reads = 0
    aux = 0
    for linea in archivo:
        if linea.startswith(inicio):
            break
    for linea in archivo:

        if linea.startswith(palabra+' ='):
            aux = aux + 1
            reads = reads + float(linea.split('=')[1])
        elif linea.startswith(fin):
            break
    return reads / aux

def IPC(nombreArchivo, monton):
    f, t= plt.subplots(1)
    #for test in grupo:
    f.set_size_inches(15, 10)
    f.set_dpi(150)
    if not os.path.exists(nombreArchivo):
        os.mkdir(nombreArchivo)

    for bench in BENCHMARKS :
        t.set_title(bench)

        try:
            for clave in sorted(TESTS.keys()) :

                df = monton[bench][clave].sum

                dato = df['total intervalo']/ df['ciclos intervalo']
                dato.plot(ax=t, label=clave, legend=True)

                plt.legend()
            t.set_ylabel('IPC')
            t.set_ylim(bottom = 0)
            t.set_xlabel('Instrucciones ejecutadas')
            #t.set_xticks([])
            f.savefig(nombreArchivo+bench+'IPC')
        except IOError as e:
            print('fallo al crear grafica ipc para:')
            print(e)
        except Exception as e:
            print('Fallo grafica ipc en el test: '+bench+' '+clave)
            print(e)
        t.cla()
    plt.close(f)
    return

def IPCmultitest_worker(directorioResultados, bench):

    tamanyoGrupo = 500000
    f, t= plt.subplots(2,3)
    f.set_size_inches(30, 20)
    f.set_dpi(300)
    t[0][0].set_title('OPC')
    t[0][1].set_title('Latencia')
    t[1][0].set_title('OPC acumulado')
    t[1][1].set_title('cantidad de accesos por intervalo')
    t[0][2].set_title('Hit Ratio L1')

    aux = pd.DataFrame()
    #aux = None;
    for exp in nombre_resumen :


        try:
            for clave in ['con L1'] :

                df = dict_por_instrucciones[exp][bench][clave].df
                ind = pd.Index(dict_por_instrucciones[exp][bench][clave].df['total global'], name='Operaciones')
                tamanyoGrupo = 10000 * np.ceil(df.shape[0]/100)

                df2 = df.set_index(ind).groupby( lambda x :  (x // tamanyoGrupo) * tamanyoGrupo).sum() #.astype(np.int32)

                if exp in nombre_resumen[3:]:
                     pd.DataFrame({exp:df2['total global']/df2['ciclos totales']}).plot(ax=t[1][2])
                     pd.DataFrame({exp:df2['mshr size L1']/tamanyoGrupo}).plot(ax=t[0][2])
                     continue

                #OPC
                dato = pd.DataFrame({exp:df2['total intervalo']/ df2['ciclos intervalo']})

                #if exists(opcOptimo)
                #opcOptimo.merge(dato)
                #dato = dato.set_index(ind).groupby( lambda x :  (x // tamanyoGrupo) * tamanyoGrupo).mean()
                dato.plot(ax=t[0][0])

                #latencia
                dato = pd.DataFrame({exp:df2['lat loads gpu']/ df2['num loads gpu']})
                #dato = dato.set_index(ind).groupby( lambda x :  (x // tamanyoGrupo) * tamanyoGrupo).mean()
                dato.plot(ax=t[0][1])

                #accesos
                dato = pd.DataFrame({exp:df2['accesos gpu']})
                dato.plot(ax=t[1][1])

                #opc acumulado
                dato = pd.DataFrame({exp:df2['total global']/df2['ciclos totales']})
                dato.plot(ax=t[1][0])
                aux = aux.join(dato, how="right")


                #hitRatio
                #pd.DataFrame({exp:(df2['hits L1']/ df2['efectivos L1'])}).replace({np.inf:0}).plot(ax=t[0][2])

                #tama√±o mshr
                #pd.DataFrame({exp:df2['mshr size L1']}).plot(ax=t[0][2])

                #plt.legend()

        except IOError as e:
            print('fallo al crear grafica opc para:')
            print(e)
        except Exception as e:
            print('Fallo grafica ipcmultitest en el test: '+bench+' '+clave)
            print(e)

    try:
        aux.max(1).plot(ax=t[1][2],style=['k--'])
        aux.min(1).plot(ax=t[1][2],style=['k--'])

        #pd.DataFrame(aux[nombre_resumen[3]]).plot(ax=t[1][2])
    except Exception as e:
        print('Fallo ipcmultitest grafica maximos y minimos en el test: '+exp)
        print(e)


    t[0][0].set_ylabel('OPC')
    t[0][0].set_ylim(bottom = 0)
    t[0][0].set_xlabel('Operaciones ejecutadas')
    #opcOptimo.plot(ax=t[0][2])
    #t[0].set_xticks([])
    #f[0].savefig(directorioResultados+bench+'_OPCmultitest')

    t[0][1].set_ylabel('Latencia (ciclos GPU)')
    t[0][1].set_ylim(bottom = 0)
    t[0][1].set_xlabel('Operaciones ejecutadas')
    #t[1].set_xticks([])

    t[1][0].set_ylabel('OPC')
    t[1][0].set_ylim(bottom = 0)
    t[1][0].set_xlabel('Operaciones ejecutadas')



    t[1][1].set_ylabel('accesos por intervalo')
    t[1][1].set_ylim(bottom = 0)
    t[1][1].set_xlabel('Operaciones ejecutadas')

    t[0][2].set_ylabel('hit Ratio(base 1)')
    t[0][2].set_ylim(bottom = 0)
    t[0][2].set_xlabel('Operaciones ejecutadas')

    t[1][2].set_ylabel('OPC')
    t[1][2].set_ylim(bottom = 0)
    t[1][2].set_xlabel('Operaciones ejecutadas')

    f.suptitle(bench+' (intervalo = '+str(tamanyoGrupo)+')', fontsize=25)
    f.savefig(directorioResultados+bench+'_OpcLatenciaMultitest-'+str(tamanyoGrupo)+'.eps',format='eps')

    #t[0].cla()
    #t[1].cla()
    plt.close(f)
    return

def IPCmultitestmultiprocess(directorioResultados):
    if not os.path.exists(directorioResultados):
        os.mkdir(directorioResultados)

    args = []
    for bench in BENCHMARKS :
        args.append((directorioResultados, bench))

    pool_ipc = multiprocessing.Pool()
    pool_ipc.starmap(IPCmultitest_worker,args)

    pool_ipc.close()
    pool_ipc.join()

    return

def benchXexp(directorioResultados, monton):

    f, t = plt.subplots(2,2)
    f.set_size_inches(30, 20)
    f.set_dpi(300)

    dir = directorioResultados+'/benchXexp/'
    if not os.path.exists(dir):
        os.mkdir(dir)

    pprint.pprint(nombre_resumen)

    for bench in sorted_nicely(BENCHMARKS) :


        latencia = pd.DataFrame(index=nombre_resumen, columns=['latencia total','latencia retry'])
        evictionsL2 = pd.DataFrame(index=nombre_resumen, columns=['evictions L2'])
        invalidations = pd.DataFrame(index=nombre_resumen, columns=['invalidations'])
        hitratio = pd.DataFrame(index=nombre_resumen, columns=['hit ratio'])
        for exp in nombre_resumen :
            try:
                df_aux = monton[exp][bench]['con L1'].df
                lat_retry = df_aux[['cycles load action retry','cycles load miss retry','cycles nc store writeback retry','cycles nc store action retry','cycles nc store miss retry']].sum().sum() / df_aux['num loads mem'].sum()

                latencia.ix[exp] = pd.DataFrame({'latencia total':(df_aux['lat loads mem'].sum() / df_aux['num loads mem'].sum()) - lat_retry, 'latencia retry':lat_retry},index=[exp]).ix[exp]

                evictionsL2.ix[exp,'evictions L2'] = df_aux['evictions L2'].sum() / df_aux['num loads mem'].sum()

                invalidations.ix[exp,'invalidations'] = df_aux['invalidations'].sum() / df_aux['num loads mem'].sum()
                pprint.pprint(contenedor_de_datos+'/'+exp+'_conL1/'+bench+'-mem-report')
                fi = open(contenedor_de_datos+'/'+exp+'_conL1/'+bench+'-mem-report')
                hitratio.ix[exp,'hit ratio'] =  buscar_y_acumular(fi,'[ l2-0 ]','[ l1-cu00 ]','HitRatio')
                fi.close()

            except IOError as e:
                print('fallo en benchXexp para:')
                print(e)
            except Exception as e:
                print('Fallo en benchXexp en el test: '+bench)
                print(e)

            latencia.plot(ax=t[0][0], kind='bar',stacked=True,title='latencia con retry')


            evictionsL2.plot(ax=t[0][1], kind='bar',stacked=True,title='evictions en L2')

            invalidations.plot(ax=t[1][0], kind='bar',stacked=True,title='invalidations')

            hitratio.plot(ax=t[1][1], kind='bar',stacked=True,title='HitRatio')

            f.savefig(dir+bench+'.eps',format='eps')
            t[0][0].cla()
            t[0][1].cla()
            t[1][0].cla()
            t[1][1].cla()

    t[0][0].cla()
    t[0][1].cla()
    t[1][0].cla()
    t[1][1].cla()
    plt.close(f)

    return

def barras_opc(directorioResultados, monton):

    dir = directorioResultados+'/barras OPC/'
    if not os.path.exists(dir):
        os.mkdir(dir)
    f, t = plt.subplots()
    f.set_size_inches(30, 20)
    f.set_dpi(300)
    opc = pd.DataFrame(index=benchmarks_amd, columns=nombre_resumen)
    invalidations = pd.DataFrame(index=benchmarks_amd, columns=nombre_resumen)
    retries = pd.DataFrame(index=benchmarks_amd, columns=nombre_resumen)
    latencia = pd.DataFrame(index=benchmarks_amd, columns=nombre_resumen)
    for exp in sorted_nicely(monton.keys()) :

        for bench in BENCHMARKS :

            try:
                df_aux = monton[exp][bench]['con L1'].df
                opc[exp][bench] = df_aux['total global'].max() / float(df_aux['ciclos totales'].max())
                invalidations[exp][bench] = df_aux['invalidations'].sum() / (df_aux['accesos gpu'].sum() - df_aux['Coalesces gpu'].sum() - df_aux['Coalesces L1'].sum())
                retries[exp][bench] = df_aux['accesses with retries'].sum() / (df_aux['accesos gpu'].sum() - df_aux['Coalesces gpu'].sum() - df_aux['Coalesces L1'].sum())
                latencia = df_aux['lat loads mem'].sum() / df_aux['num loads mem'].sum()

            except Exception as e:
                print('Fallo barras_opc(): '+exp+' '+bench)
                print(e)

        #latencia retry


    opc.plot(ax=t, kind='bar')
    f.savefig(dir + 'opc.eps',format='eps')
    t.cla()

    invalidations.plot(ax=t, kind='bar')
    f.savefig(dir + 'invalidations.eps',format='eps')
    t.cla()

    retries.plot(ax=t, kind='bar')
    f.savefig(dir + 'retries.eps',format='eps')
    t.cla()
    plt.close(f)

    return


def analisis_stall(directorioResultados, monton):

    dir = directorioResultados+'/barras OPC/'
    if not os.path.exists(dir):
        os.mkdir(dir)

    dir_latencias = directorioResultados+'/por_instrucciones/latencias/'
    if not os.path.exists(dir_latencias):
        os.mkdir(dir_latencias)

    df_exp = pd.DataFrame()

    for exp in sorted_nicely(monton.keys()) :
        df_fetch = pd.DataFrame(index=sorted_nicely(monton[exp].keys()),columns = ['no stall','stall mem access','stall barrier','stall instruction infly','stall fetch buffer full','stall no wavefront','stall others'])
        df_dispatch = pd.DataFrame(index=sorted_nicely(monton[exp].keys()),columns = ['cycles simd running','dispatch stall others','dispatch stall barrier','dispatch stall mem access','dispatch stall instruction infly'])
        df_instructions = pd.DataFrame(index=sorted_nicely(monton[exp].keys()),columns = ['i scalar','mi simd','i branch','mi lds','i s mem','mi v mem'])
        df_operations = pd.DataFrame(index=sorted_nicely(monton[exp].keys()),columns = ['i scalar', 'i simd', 'i s mem', 'i v mem', 'i branch', 'i lds',])
        df_instructions_infly = pd.DataFrame(index=sorted_nicely(monton[exp].keys()),columns = ['dispatch branch instruction infly', 'dispatch scalar instruction infly','dispatch simd instruction infly', 'dispatch lds instruction infly', 'dispatch mem scalar instruction infly', 'dispatch v mem instruction infly'])

        for bench in BENCHMARKS:
            try:
                df_max = pd.DataFrame(monton[exp][bench]['con L1'].df.max(),columns=[bench]).transpose()
                df_sum = pd.DataFrame(monton[exp][bench]['con L1'].df.sum(),columns=[bench]).transpose()

                df_fetch.ix[bench] = df_max.ix[bench,['no stall','stall mem access','stall barrier','stall instruction infly','stall no wavefront','stall others','stall fetch buffer full']]
                df_dispatch.ix[bench] = df_max.ix[bench,['cycles simd running','dispatch stall mem access','dispatch stall barrier','dispatch stall instruction infly','dispatch stall others']]
                df_instructions_infly.ix[bench] = df_max.ix[bench,['dispatch branch instruction infly', 'dispatch scalar instruction infly', 'dispatch mem scalar instruction infly', 'dispatch simd instruction infly', 'dispatch v mem instruction infly', 'dispatch lds instruction infly']]


                df_instructions.ix[bench] = df_sum.ix[bench,['i scalar', 'mi simd', 'i s mem', 'mi v mem', 'i branch', 'mi lds',]]

                df_operations.ix[bench] = df_sum.ix[bench,['i scalar', 'i simd', 'i s mem', 'i v mem', 'i branch', 'i lds',]]

                #comparacion latencias
                df_lat = monton[exp][bench]['con L1'].df

                latencia_retries = pd.DataFrame({'retry lat':df_lat[['cycles load action retry','cycles load miss retry','cycles nc store writeback retry','cycles nc store action retry','cycles nc store miss retry']].sum(1) / df_lat['num loads mem']})
                                                             #df_lat[['counter load action retry','counter load miss retry','counter nc store writeback retry','counter nc store action retry','counter nc store miss retry']].sum(1)})
                latencia_total = pd.DataFrame({'latencia total':df_lat['lat loads mem'] /  df_lat['num loads mem']})

                f2, t2 = plt.subplots()
                f2.set_size_inches(30, 20)
                f2.set_dpi(300)

                pd.rolling_mean(latencia_retries, 20).plot(ax=t2)
                pd.rolling_mean(latencia_total, 20).plot(ax=t2)
                f2.savefig(dir_latencias + bench +'_'+exp+'.eps',format='eps')

                t2.cla()
                plt.close(f2)

            except Exception as e:
                print('Fallo analisis stall(): '+exp+' '+bench)
                print(e)

        df_fetch = df_fetch.div(df_fetch.sum(1), axis=0)
        df_dispatch[['dispatch stall mem access','dispatch stall barrier','dispatch stall instruction infly','dispatch stall others']] = df_dispatch[['dispatch stall mem access','dispatch stall barrier','dispatch stall instruction infly','dispatch stall others']] / 10

        #prueba
        df_dispatch_aux = pd.DataFrame(df_dispatch)
        df_exp = df_exp.append(pd.DataFrame(df_dispatch.values,index= pd.MultiIndex.from_product([[exp],df_dispatch.index]) ,columns=df_dispatch.columns))

        df_dispatch = df_dispatch.div(df_dispatch.sum(1), axis=0)
        df_instructions = df_instructions.div(df_instructions.sum(1), axis=0)
        df_operations = df_operations.div(df_operations.sum(1), axis=0)
        df_instructions_infly = df_instructions_infly.div(df_instructions_infly.sum(1), axis=0)

        f, t = plt.subplots()
        f.set_size_inches(30, 20)
        f.set_dpi(300)

        df_fetch.plot(ax=t, kind='bar',stacked=True)
        f.suptitle(exp +'_fetch_stall', fontsize=25)
        f.savefig(dir + exp +'_fetch_stall.eps',format='eps')
        t.cla()

        df_instructions.plot(ax=t, kind='bar',stacked=True)
        f.suptitle(exp +'_instructions', fontsize=25)
        f.savefig(dir + exp +'_instructions.eps',format='eps')
        t.cla()

        df_operations.plot(ax=t, kind='bar',stacked=True)
        f.suptitle(exp +'_operations', fontsize=25)
        f.savefig(dir + exp +'_operations.eps',format='eps')
        t.cla()

        plt.close(f)

        f, t = plt.subplots(1,2)
        f.set_size_inches(30, 20)
        f.set_dpi(300)
        #plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))

        df_dispatch.columns = ['cycles simd running','others stalls','barrier stall','memory fence stall','instruction infly stall']
        df_dispatch.plot(ax=t[0], kind='bar',stacked=True,title='cicles idle').legend(loc='upper left', bbox_to_anchor=(0.6, 1.15))
        #f.savefig(dir + exp +'_dispatch_stall.eps',format='eps')

        df_instructions_infly.plot(ax=t[1], kind='bar',stacked=True,title='instructions in fly').legend(loc='upper left', bbox_to_anchor=(0.6, 1.15))
        t[0].set_ylim(0,1)
        t[1].set_ylim(0,1)
        f.suptitle(exp +'_dispatch_stall', fontsize=25)
        f.savefig(dir + exp +'_dispatch_stall.eps',format='eps', bbox_inches='tight')

        plt.close(f)

    #grafica para comparar los distintos experimentos


    for i in BENCHMARKS:

        f, t = plt.subplots()
        f.set_size_inches(30, 20)
        f.set_dpi(300)

        df_exp.xs(i,level=1).plot(ax=t, kind='bar',stacked=True,title=i)
        f.savefig(dir + 'exp_'+i+'.eps',format='eps',bbox_inches='tight')
        t.cla()
        plt.close(f)




    return


'''def analisis_stall(directorioResultados, monton):

    dir = directorioResultados+'/barras OPC/'
    if not os.path.exists(dir):
        os.mkdir(dir)
    f, t = plt.subplots()
    f.set_size_inches(30, 20)
    f.set_dpi(300)
    for exp in sorted(monton.keys()) :

        df_aux = pd.DataFrame(index=sorted(monton[exp].keys()), columns=['no stall','stall mem access','stall barrier','stall instruction infly','stall fetch buffer full','stall no wavefront','stall others'])

        for bench in sorted(monton[exp].keys()):
            try:
                df = pd.DataFrame(monton[exp][bench]['con L1'].df.max()).transpose()

                for col in ['no stall','stall mem access','stall barrier','stall instruction infly','stall fetch buffer full','stall no wavefront','stall others']:

                    df_aux.loc[bench,col] = (df[col+str(0)][0] + df[col+str(1)][0] + df[col+str(2)][0] + df[col+str(3)][0]+ df[col+str(4)][0]) / 5

            except Exception as e:
                print('Fallo analisis stall(): '+exp+' '+bench)
                print(e)

        df_aux = df_aux.div(df_aux.sum(1), axis=0)
        df_aux.plot(ax=t, kind='bar',stacked=True)

        f.savefig(dir + exp+'stall.eps',format='eps')

    t.cla()
    plt.close(f)

    return'''

def IPCmultitest(directorioResultados, monton):

    if not os.path.exists(directorioResultados):
        os.mkdir(directorioResultados)

    dirLatencias = directorioResultados+'/latencias/'
    if not os.path.exists(dirLatencias):
        os.mkdir(dirLatencias)

    tamanyoGrupo = 500000
    for bench in BENCHMARKS :

        f_lat, t_lat = plt.subplots(2,4)
        f_lat.set_size_inches(30, 20)
        f_lat.set_dpi(300)
        t_lat[0][0].set_title('lock mshr')
        t_lat[0][1].set_title('lock dir')
        t_lat[0][2].set_title('finish')

        f, t= plt.subplots(2,3)
        f.set_size_inches(30, 20)
        f.set_dpi(300)
        t[0][0].set_title('OPC')
        t[0][1].set_title('Latencia')
        t[1][0].set_title('tiempo vector mem buffer full')
        t[1][1].set_title('tiempo simd idle')
        t[0][2].set_title('Tama√±o MSHR')

        aux = pd.DataFrame()
        #aux = None;
        for exp in nombre_resumen :


            try:
                for clave in ['con L1'] :

                    df = monton[exp][bench][clave].df
                    ind = pd.Index(monton[exp][bench][clave].df['total global'], name='Operaciones')
                    tamanyoGrupo = 10000 * np.ceil(df.shape[0]/100)

                    df2 = df.set_index(ind).groupby( lambda x :  (x // tamanyoGrupo) * tamanyoGrupo).sum() #.astype(np.int32)
                    df_cumsum = df2.cumsum()

                    if exp in nombre_resumen[0:]:
                        pd.DataFrame({exp:df_cumsum['total intervalo']/df_cumsum['ciclos intervalo']}).plot(ax=t[1][2],legend=False)
                        pd.DataFrame({exp:df2['mshr size L1']/(tamanyoGrupo/10000)}).plot(ax=t[0][2],legend=False)
                        pd.DataFrame({exp:df2['lat loads gpu']/ df2['num loads gpu']}).plot(ax=t[0][1],legend=False)
                        pd.DataFrame({exp:df2['total intervalo']/ df2['ciclos intervalo']}).plot(ax=t[0][0])
                        if 'simd idle1' in df2.columns:
                            dato = pd.DataFrame({exp:((df2['simd idle1'] + df2['simd idle2'] + df2['simd idle3'] + df2['simd idle4']) / (4 * 5)) / df2['ciclos intervalo']}).plot(ax=t[1][1],legend=False)
                            dato.plot(ax=t[1][1],legend=False)
                        #LATENCIAS
                        pd.DataFrame({exp:df2['lock mshr load']/df2['access load']}).plot(ax=t_lat[0][0])
                        pd.DataFrame({exp:df2['evicted dir load']/df2['access load']}).plot(ax=t_lat[0][1],legend=False)
                        pd.DataFrame({exp:df2['lock mshr load']/df2['access load'] + df2['evicted dir load']/df2['access load']}).plot(ax=t_lat[0][2],legend=False)
                        pd.DataFrame({exp:df2['finish load']/df2['access load']}).plot(ax=t_lat[0][3],legend=False)

                        pd.DataFrame({exp:df2['hits L1']/df2['efectivos L1']}).plot(ax=t_lat[1][0],legend=False,title='HitRatio L1')
                        pd.DataFrame({exp:df2['hits L2']/df2['efectivos L2']}).plot(ax=t_lat[1][1],legend=False,title='HitRatio L2')


                        pd.DataFrame({exp:df2['lat loads gpu']/df2['num loads gpu']}).plot(ax=t_lat[1][2],legend=False,title='Latencia GPU')
                        pd.DataFrame({exp:df2['Coalesces L1']/df2['accesos L1']}).plot(ax=t_lat[1][3],legend=False,title='coalesce GPU')
                        t_lat[1][0].set_ylim([0,1])
                        t_lat[1][1].set_ylim([0,1])
                        t_lat[1][2].set_ylim(bottom = 0)
                        t_lat[1][3].set_ylim([0,1])
                        '''pd.DataFrame({exp:df2['lock mshr nc write']/df2['access nc write']}).plot(ax=t_lat[1][0],legend=False)
                        pd.DataFrame({exp:df2['evicted dir nc write']/df2['access nc write']}).plot(ax=t_lat[1][1],legend=False)
                        pd.DataFrame({exp:df2['lock mshr nc write']/df2['access nc write'] + df2['evicted dir nc write']/df2['access nc write']}).plot(ax=t_lat[1][2],legend=False)
                        pd.DataFrame({exp:df2['finish nc write']/df2['access nc write']}).plot(ax=t_lat[1][3],legend=False)'''
                        #continue

                    #OPC
                    #dato = pd.DataFrame({exp:df2['total intervalo']/ df2['ciclos intervalo']})

                    #if exists(opcOptimo)
                    #opcOptimo.merge(dato)
                    #dato = dato.set_index(ind).groupby( lambda x :  (x // tamanyoGrupo) * tamanyoGrupo).mean()
                    #dato.plot(ax=t[0][0])

                    #latencia
                    #dato = pd.DataFrame({exp:df2['lat loads gpu']/ df2['num loads gpu']})
                    #dato.plot(ax=t[0][1])

                    #accesos
                    #dato = pd.DataFrame({exp:df2['efectivos L1']/df2['ciclos intervalo']}).plot(ax=t[1][1])
                    #dato.plot(ax=t[1][1])

                    #if 'simd idle1' in df2.columns:
                    #    dato = pd.DataFrame({exp:((df2['simd idle1'] + df2['simd idle2'] + df2['simd idle3'] + df2['simd idle4']) / (4 * 5)) / df2['ciclos intervalo']}).plot(ax=t[1][1])
                    #    dato.plot(ax=t[1][1])

                    #opc acumulado
                    dato = pd.DataFrame({exp:df_cumsum['total intervalo']/df_cumsum['ciclos intervalo']})
                    aux = aux.join(dato, how="right")

                    #v_mem_full
                    dato = pd.DataFrame({exp:(df2['v mem full'] / 5)/df2['ciclos intervalo']})
                    dato.plot(ax=t[1][0],legend=False)


                    #hitRatio
                    #pd.DataFrame({exp:(df2['hits L1']/ df2['efectivos L1'])}).replace({np.inf:0}).plot(ax=t[0][2])

                    #tama√±o mshr
                    #pd.DataFrame({exp:df2['mshr size L1']}).plot(ax=t[0][2])

                    #plt.legend()

                    #LATENCIAS
                    #pd.DataFrame({exp:df2['lock mshr load']/df2['access load']}).plot(ax=t_lat[0][0])
                    #pd.DataFrame({exp:df2['evicted dir load']/df2['access load']}).plot(ax=t_lat[0][1])
                    #pd.DataFrame({exp:df2['lock mshr load']/df2['access load'] + df2['evicted dir load']/df2['access load']}).plot(ax=t_lat[0][2])
                    #pd.DataFrame({exp:df2['finish load']/df2['access load']}).plot(ax=t_lat[0][3])
                    #pd.DataFrame({exp:df2['lock mshr nc write']/df2['access nc write']}).plot(ax=t_lat[1][0])
                    #pd.DataFrame({exp:df2['evicted dir nc write']/df2['access nc write']}).plot(ax=t_lat[1][1])
                    #pd.DataFrame({exp:df2['lock mshr nc write']/df2['access nc write'] + df2['evicted dir nc write']/df2['access nc write']}).plot(ax=t_lat[1][2])
                    #pd.DataFrame({exp:df2['finish nc write']/df2['access nc write']}).plot(ax=t_lat[1][3])

            except IOError as e:
                print('fallo al crear grafica opc para:')
                print(e)
            except Exception as e:
                print('Fallo grafica ipcmultitest en el test: '+bench+' '+clave)
                print(e)

        try:
            aux.max(1).plot(ax=t[1][2],style=['k--'],legend=False)
            aux.min(1).plot(ax=t[1][2],style=['k--'],legend=False)

            #pd.DataFrame(aux[nombre_resumen[3]]).plot(ax=t[1][2])
        except Exception as e:
            print('Fallo ipcmultitest grafica maximos y minimos en el test: '+exp)
            print(e)


        t[0][0].set_ylabel('OPC')
        t[0][0].set_ylim(bottom = 0)
        t[0][0].set_xlabel('Operaciones ejecutadas')
        #opcOptimo.plot(ax=t[0][2])
        #t[0].set_xticks([])
        #f[0].savefig(directorioResultados+bench+'_OPCmultitest')

        t[0][1].set_ylabel('Latencia (ciclos GPU)')
        t[0][1].set_ylim(bottom = 0)
        t[0][1].set_xlabel('Operaciones ejecutadas')
        #t[1].set_xticks([])

        t[1][0].set_ylabel('% tiempo vector mem buffer full')
        t[1][0].set_ylim(bottom = 0)
        t[1][0].set_xlabel('Operaciones ejecutadas')



        t[1][1].set_ylabel('% medio de ciclos simd idle')
        t[1][1].set_ylim(bottom = 0)
        t[1][1].set_xlabel('Operaciones ejecutadas')

        t[0][2].set_ylabel('Cantidad de entradas')
        t[0][2].set_ylim(bottom = 0)
        t[0][2].set_xlabel('Operaciones ejecutadas')

        t[1][2].set_ylabel('OPC')
        t[1][2].set_ylim(bottom = 0)
        t[1][2].set_xlabel('Operaciones ejecutadas')

        max_load = max([t_lat[0][0].get_ylim()[1], t_lat[0][1].get_ylim()[1], t_lat[0][2].get_ylim()[1]])
        max_write = max([t_lat[1][0].get_ylim()[1], t_lat[1][1].get_ylim()[1], t_lat[1][2].get_ylim()[1]])

        t_lat[0][0].set_ylim(bottom = 0, top = max_load)
        t_lat[0][1].set_ylim(bottom = 0, top = max_load)
        t_lat[0][2].set_ylim(bottom = 0, top = max_load)
        t_lat[0][3].set_ylim(bottom = 0, top = max_load)
        '''t_lat[1][0].set_ylim(bottom = 0, top = max_write)
        t_lat[1][1].set_ylim(bottom = 0, top = max_write)
        t_lat[1][2].set_ylim(bottom = 0, top = max_write)
        t_lat[1][3].set_ylim(bottom = 0, top = max_write)
        '''



        f.suptitle(bench+' (intervalo = '+str(tamanyoGrupo)+')', fontsize=25)
        f.savefig(directorioResultados+bench+'_OpcMultitest-'+str(tamanyoGrupo)+'.eps',format='eps')

        f_lat.suptitle(bench+' (intervalo = '+str(tamanyoGrupo)+')', fontsize=25)
        f_lat.savefig(dirLatencias+bench+'_Multitest-'+str(tamanyoGrupo)+'.eps',format='eps')
        #t[0].cla()
        #t[1].cla()
        plt.close(f)
        plt.close(f_lat)
    return



def IPCacumulado(nombreArchivo):
    f, t= plt.subplots(1)
    #for test in grupo:

    if not os.path.exists(directorio_salida+'/graficos/ipc'):
        os.mkdir(directorio_salida+'/graficos/ipc')

    for bench in BENCHMARKS :
        t.set_title(bench+' - IPC acumulado')
        try:
            for clave in sorted(TESTS.keys()) :
                dato = aux[bench][clave].df['total global']
                #pd.DataFrame({clave :np.loadtxt( contenedor_de_datos+'/'+TESTS[clave]+'/'+bench+'-fran_ipc',delimiter = '\n')})
                #dato = pd.DataFrame({clave : aux[bench][clave].df['ipc']})
                dato = dato.groupby( lambda x :  x // (np.ceil(dato.shape[0]/100))).mean()
                dato.plot(ax=t )

            t.set_ylabel('IPC')
            t.set_xlabel('Instrucciones ejecutadas')
            t.set_xticks([])
            #'''np.arange(np.ceil(dato.shape[0]/100))*50000''')
            f.savefig(nombreArchivo+bench+'-acumulado')
        except IOError as e:
            print('fallo al crear grafica ipc para:')
            print(e)
        except Exception as e:
            print('Fallo grafica ipc en el test: '+bench+' '+clave)
            print(e)
        t.cla()
    plt.close(f)
    return

'''def dibujar4tablas(nombreArchivo,monton):

    #for test in grupo:
    if not os.path.exists(nombreArchivo):
        os.mkdir(nombreArchivo)

    for bench in BENCHMARKS :

        f, t= plt.subplots(2,2)
        f.get_size_inches()
        f.set_size_inches(20, 14)
        f.set_dpi(50)

        try:
            for clave in TESTS.keys() :
                #dato = pd.DataFrame({clave : monton[bench][clave].df['Coalesces L1']})
                #dato = pd.DataFrame({clave : aux[bench][clave].df['ipc']})

                #dato = dato.groupby( lambda x :  x // resolucion).mean()
                #dato.plot(ax=t[0][0])

                #dato = pd.DataFrame({clave : monton[bench][clave].df['accesos L1']})
                #dato = pd.DataFrame({clave : aux[bench][clave].df['ipc']})
                #dato = dato.groupby( lambda x :  x // resolucion).mean()
                #dato.plot(ax=t[0][0],secondary_y=True)

                t[0][0].set_title('Coalesces / accesos efectivos')
                t[0][0].set_ylabel('(coalesces / accesos) en L1')

                efectivos = monton[bench][clave].df['accesos L2'] - monton[bench][clave].df['Coalesces L2']
                dato = pd.DataFrame({clave: (monton[bench][clave].df['Coalesces L2'] / efectivos)})
                resolucion = np.ceil(dato.shape[0]/100)

                dato = dato.groupby( lambda x :  x // resolucion).mean()
                dato.plot(ax=t[0][0],secondary_y=True)
                t[0][0].right_ax.set_ylabel('(coalesces / accesos) en L2')

                efectivos = monton[bench][clave].df['accesos L1'] - monton[bench][clave].df['Coalesces L1']
                dato = pd.DataFrame({clave: (monton[bench][clave].df['Coalesces L1'] / efectivos )})

                dato = dato.groupby( lambda x :  x // resolucion).mean()
                dato.plot(ax=t[0][0])

                dato = pd.DataFrame({clave : monton[bench][clave].df['MPKI L2']})
                #dato = pd.DataFrame({clave : aux[bench][clave].df['ipc']})
                dato = dato.groupby( lambda x :  x // resolucion).mean()
                dato.plot(ax=t[0][1],secondary_y=True)

                dato = pd.DataFrame({clave : monton[bench][clave].df['MPKI L1']})
                #dato = pd.DataFrame({clave : aux[bench][clave].df['ipc']})
                dato = dato.groupby( lambda x :  x // resolucion).mean()
                dato.plot(ax=t[0][1])

                dato = pd.DataFrame({clave : monton[bench][clave].df['HR L1']})
                #dato = pd.DataFrame({clave : aux[bench][clave].df['ipc']})
                dato = dato.groupby( lambda x :  x // resolucion).mean()
                dato.plot(ax=t[1][0])

                dato = pd.DataFrame({clave : monton[bench][clave].df['HR L2']})
                #dato = pd.DataFrame({clave : aux[bench][clave].df['ipc']})
                dato = dato.groupby( lambda x :  x // resolucion).mean()
                dato.plot(ax=t[1][1])

            f.set_label('LABEL DE LA FIGURA')
            #t[0][0].set_title('Coalesces y accesos L1')
            t[0][1].set_title('MPKI')
            t[1][0].set_title('HR L1')
            t[1][1].set_title('HR L2')

            #t[0][0].set_ylabel('cantidad de coalesces')
            #t[0][0].right_ax.set_ylabel('accesos')
            #t[0][0].set_xlabel('Instrucciones ejecutadas')

            t[0][1].set_ylabel('Misses / 1000 inst')
            t[0][1].right_ax.set_ylabel('MPKI L2')
            #t[0][1].set_xlabel('Instrucciones ejecutadas')

            t[1][0].set_ylabel('hit ratio % (base 1)')
            #t[1][0].set_xlabel('Instrucciones ejecutadas')

            t[1][1].set_ylabel('hit ratio % (base 1)')
            #t[1][1].set_xlabel('Instrucciones ejecutadas')
            #t[0][0].set_xticks(np.arange(np.ceil(dato.shape[0]/100))*50000)

            f.savefig(nombreArchivo+'/'+bench)



        except IOError as e:
            print('fallo al crear grafica ipc para:')
            print(e)
        except Exception as e:
            print('Fallo dibujar4tablas en el test: '+bench+' '+clave)
            print(e)

        plt.close(f)
    return
'''

def dibujar4tablas(nombreArchivo,monton,exp):

    #for test in grupo:
    if not os.path.exists(nombreArchivo):
        os.mkdir(nombreArchivo)

    TESTS = {'con L1':exp+'_conL1'}

    for bench in BENCHMARKS :

        f, t= plt.subplots(2,3)
        f.set_size_inches(30, 15)
        f.set_dpi(150)

        try:
            # grafica coalesces / efectivos para L1 y L2(izquierda)
            t[0][0].set_title('Coalesces / accesos efectivos')

            for clave in sorted(TESTS.keys()) :

                df = monton[bench][clave].media

                efectivos = df['efectivos L2']
                dato = pd.DataFrame({'L2 ('+ clave +')': (df['Coalesces L2'] / efectivos)})

                dato.plot(ax=t[0][0])

                efectivos = df['efectivos L1']
                dato = pd.DataFrame({'L1 ('+ clave +')': (df['Coalesces L1'] / efectivos )})

                dato.plot(ax=t[0][0])

                efectivos = pd.DataFrame({'as':df['accesos gpu'] - df['Coalesces gpu']})

                dato = pd.DataFrame({'gpu ('+ clave +')': (df['Coalesces gpu'] / efectivos['as'] )})

                dato.plot(ax=t[0][0])

            t[0][0].set_ylabel('(coalesces / accesos efectivos)')
            #t[0][0].right_ax.set_ylabel('(coalesces / accesos) en L2')
            t[0][0].set_xlabel('Instrucciones ejecutadas')

            # grafica MKPI L1 y L2(izquierda)
            t[0][1].set_title('MPKI')

            for clave in sorted(TESTS.keys()) :

                df = monton[bench][clave].media

                dato = pd.DataFrame({'L2 ('+ clave +')': df['misses L2']/10})
                dato.plot(ax=t[0][1])

                dato = pd.DataFrame({'L1 ('+ clave +')' : df['misses L1']/10})
                dato.plot(ax=t[0][1])

            t[0][1].set_ylabel('MPKI')
            #t[0][1].right_ax.set_ylabel('MPKI L2')
            t[0][1].set_xlabel('Instrucciones ejecutadas')

            #IPC
            t[1][1].set_title('IPC')
            for clave in sorted(TESTS.keys()) :

                df = monton[bench][clave].sum

            #    dato = pd.DataFrame({clave : df['total intervalo']/ df['ciclos intervalo']})
                dato = pd.DataFrame({clave : df['total intervalo']/ (df['ciclos intervalo'] )})
                dato.plot(ax=t[1][1])
            t[1][1].set_ylabel('IPC')
            t[1][1].set_ylim(bottom = 0)
            t[1][1].set_xlabel('Instrucciones ejecutadas')

            #Graficas HR L1 y HR L2
            t[1][0].set_title('HitRatio L1 y L2')
            #t[1][1].set_title('hits L2')
            for clave in sorted(TESTS.keys()) :

                df = monton[bench][clave].media

                efectivos = df['efectivos L1']
                dato = pd.DataFrame({'HR L1 ('+clave+')' : df['hits L1'] / efectivos})
                dato.plot(ax=t[1][0])

                efectivos = df['efectivos L2']
                dato = pd.DataFrame({'HR L2 ('+clave+')' : df['hits L2'] / efectivos})
                dato.plot(ax=t[1][0])

            t[1][0].set_ylabel('hit ratio % (base 1)')
            #t[1][1].set_ylabel('hit ratio % (base 1)')
            t[1][0].set_xlabel('Instrucciones ejecutadas')
            #t[1][1].set_xlabel('Instrucciones ejecutadas')

            #grafica latencias de red para L1 y L2(izqueirda)
            ''' t[0][2].set_title('Latencia red')
            for clave in sorted(TESTS.keys()) :

                df = monton[bench][clave].media

                paquetes = df['paquetes L2-MM']
                dato = pd.DataFrame({'red L2-MM ('+ clave+')': ((df['lat L2-MM'] / 8) / paquetes)})

                dato.plot(ax=t[0][2])

                paquetes = df['paquetes L1-L2']
                dato = pd.DataFrame({'red L1-L2 ('+ clave+')': ((df['lat L1-L2'] / 8) / paquetes)})

                dato.plot(ax=t[0][2])

            t[0][2].set_ylabel('ciclos de latencia (L1-L2)')
            #t[0][2].right_ax.set_ylabel('ciclos de latencia (L2-MM)')
            t[0][2].set_xlabel('Instrucciones ejecutadas')'''

            #grafica latencias de red para L1 y L2(izqueirda)
            t[1][2].set_title('Latencia load')
            for clave in sorted(TESTS.keys()) :

                df = monton[bench][clave].media

                latencia = df['lat loads gpu']
                peticiones = df['num loads gpu']
                dato = pd.DataFrame({'GPU loads ('+ clave+')': latencia / peticiones})

                dato.plot(ax=t[1][2])

                latencia = df['lat loads mem']
                peticiones = df['num loads mem']
                dato = pd.DataFrame({'MEM-SYSTEM loads ('+ clave+')': latencia / peticiones})

                dato.plot(ax=t[1][2])

            t[1][2].set_ylabel('ciclos de latencia (GPU)')
            #t[1][2].right_ax.set_ylabel('ciclos de latencia (MEM-SYSTEM)')
            t[1][2].set_xlabel('Instrucciones ejecutadas')


            #grafica latencias de red para L1 y L2(izqueirda)
            ''' t[0][3].set_title('load efectivas')
            for clave in sorted(TESTS.keys()) :

                df = monton[bench][clave].sum

                dato = pd.DataFrame({'loads/instruccion ('+ clave+')': df['efectivos L1']/df['total intervalo']})

                dato.plot(ax=t[0][3])

            t[0][3].set_ylabel('cantidad de loads')
            #t[1][2].right_ax.set_ylabel('ciclos de latencia (MEM-SYSTEM)')
            t[0][3].set_xlabel('Instrucciones ejecutadas')
            t[0][3].set_ylim(bottom = 0)'''

            #grafica latencias de red para L1 y L2(izqueirda)
            t[0][2].set_title('entradas bloqueadas')
            for clave in sorted(TESTS.keys()) :

                df = monton[bench][clave].media

                dato = pd.DataFrame({'L1 ('+ clave+')': df['entradas bloqueadas L1'], 'L2 ('+ clave+')': df['entradas bloqueadas L2']})

                dato.plot(ax=t[0][2])

            t[0][2].set_ylabel('numero de entradas bloqueadas')
            #t[1][2].right_ax.set_ylabel('ciclos de latencia (MEM-SYSTEM)')
            t[0][2].set_xlabel('Instrucciones ejecutadas')

            f.suptitle(EXPERIMENTO +' - '+ bench, fontsize=25)
            f.savefig(nombreArchivo+'/'+bench)



        except IOError as e:
            print('fallo al crear grafica ipc para:')
            print(e)
        except Exception as e:
            print('Fallo dibujar4tablas en el test: '+bench+' '+clave)
            print(e)
        t[0][0].cla()
        t[0][1].cla()
        t[0][2].cla()
        #t[0][3].cla()
        t[1][0].cla()
        t[1][1].cla()
        t[1][2].cla()
        #t[1][3].cla()
        plt.close(f)
    return

def dibujar4tablas2(nombreArchivo,monton):

    #for test in grupo:
    if not os.path.exists(nombreArchivo):
        os.mkdir(nombreArchivo)

    for bench in BENCHMARKS :

        f, t= plt.subplots(2,3)
        f.set_size_inches(20, 10)
        f.set_dpi(150)

        try:
            # nivel de paralelismo
            t[0][0].set_title('nivel de paralalismo (max 64)')

            df = monton[bench]['con L1'].sum

            simd = df['i simd'] / df['mi simd']
            v_mem = df['i v mem'] / df['mi v mem']

            dato = pd.DataFrame({'SIMD': simd})
            dato.plot(ax=t[0][0])
            dato = pd.DataFrame({'Memoria': v_mem})
            dato.plot(ax=t[0][0])

            t[0][0].set_ylim(bottom = 0)
            t[0][0].set_ylabel('(thread)')
            t[0][0].set_xlabel('Instrucciones ejecutadas')


            # reads y write
            t[0][1].set_title('read y write')


            df = monton[bench]['con L1'].media
            write = df['writesL1']
            load = df['loadsL1']

            dato = pd.DataFrame({'writes': write})
            dato.plot(ax=t[0][1])
            dato = pd.DataFrame({'loads': load})
            dato.plot(ax=t[0][1])


            t[0][1].set_ylim(bottom = 0)
            t[0][1].set_ylabel('cantidad de accesos efectivos')
            t[0][1].set_xlabel('Instrucciones ejecutadas')

            # Coalesce Gpu
            t[1][1].set_title('Coalesce GPU')

            df = monton[bench]['con L1'].sum

            dato = pd.DataFrame({'Coalesce': (df['Coalesces gpu'])})

            dato.plot(ax=t[0][2])
            dato = pd.DataFrame({'accesses': (df['accesos gpu'])})
            dato.plot(ax=t[0][2])

            t[1][1].set_ylim(bottom = 0)
            t[1][1].set_ylabel('(HR con coalesces)')
            t[1][1].set_xlabel('Instrucciones ejecutadas')

            f.suptitle(bench, fontsize=25)
            f.savefig(nombreArchivo+'/'+bench+'HRcoalesce')

        except IOError as e:
            print('fallo al crear grafica ipc para:')
            print(e)
        except Exception as e:
            print('Fallo dibujar4tablas2 en el test: '+bench)
            print(e)

        plt.close(f)
    return


def comparar_velocidad(nombreArchivo):
    f, t= plt.subplots(1)
    #for test in grupo:
    t.set_title('comparacion lat ')
    TESS = {'10_lat_conL1':'05-15_prueba_10_lat_conL1','100_lat_conL1':'05-15_prueba_100_lat_conL1'}

    for bench in BENCHMARKS :

        try:
            dato = pd.DataFrame({'10_lat_conL1' : np.loadtxt( contenedor_de_datos+'/'+TESS['10_lat_conL1']+'/'+bench+'-fran_t10000k',delimiter = '\n')})
            dato1 = pd.DataFrame({'100_lat_conL1' : np.loadtxt( contenedor_de_datos+'/'+TESS['100_lat_conL1']+'/'+bench+'-fran_t10000k',delimiter = '\n')})
            #dato = dato['10_lat_conL1'] - dato1['100_lat_conL1']
            dato = dato.join(dato1)
            dato.plot(ax=t)

            t.set_ylabel('ciclos')
            t.set_xlabel('loads')
            t.set_xticks([])
            f.savefig(nombreArchivo+bench)
        except IOError as e:
            print('fallo al crear grafica ipc para:')
            print(e)
        except Exception as e:
            print('Fallo grafica ipc en el test: '+bench)
            print(e)
        t.cla()
    plt.close(f)
    return

class contenedor:
        pass

class NoDaemonProcess(multiprocessing.Process):
    # make 'daemon' attribute always return False
    def _get_daemon(self):
        return False
    def _set_daemon(self, value):
        pass
    daemon = property(_get_daemon, _set_daemon)

class MyPool(multiprocessing.pool.Pool):
    Process = NoDaemonProcess

def loadDictCompletomultiprocesses2(sufijo, contenedor_de_datos, exp, bench, tip=None):


    #TESTS = {'sin L1':EXPERIMENTO+'_sinL1','con L1':EXPERIMENTO+'_conL1'}
    TESTS = {'con L1':exp+'_conL1'}


    directorio_salida = contenedor_de_datos+'/'+exp+'_resumen'
    DIR_GRAFICOS = directorio_salida+'/graficos'
    '''
    # crear directorios
    if not os.path.exists(directorio_salida):
        os.mkdir(directorio_salida)
    if not os.path.exists(directorio_salida+'/tablas'):
        os.mkdir(directorio_salida+'/tablas')
    if not os.path.exists(directorio_salida+'/graficos'):
        os.mkdir(directorio_salida+'/graficos')'''


    return loadworker(bench,sufijo,TESTS,contenedor_de_datos)


def loadDictCompletomultiprocesses(sufijo, contenedor_de_datos, exp, tip=None):
    directorio_salida = contenedor_de_datos+'/'+exp+'_resumen'

    #TESTS = {'sin L1':EXPERIMENTO+'_sinL1','con L1':EXPERIMENTO+'_conL1'}
    TESTS = {'con L1':exp+'_conL1'}
    DIR_GRAFICOS = directorio_salida+'/graficos'



    # crear directorios
    if not os.path.exists(directorio_salida):
        os.mkdir(directorio_salida)
    if not os.path.exists(directorio_salida+'/tablas'):
        os.mkdir(directorio_salida+'/tablas')
    if not os.path.exists(directorio_salida+'/graficos'):
        os.mkdir(directorio_salida+'/graficos')
    args = []
    for bench in BENCHMARKS :
        args.append((bench,sufijo,TESTS,contenedor_de_datos))

    pool = multiprocessing.Pool()
    resultados_load = pool.starmap(loadworker, args)
    print('lanzado 2')
    pool.close()
    pool.join()
    print(resultados_load)
    dict_general = dict(zip(BENCHMARKS,resultados_load))
    return dict_general

def loadworker(bench,sufijo, TESTS, contenedor_de_datos):
    dict_general = dict()

    print('cargando -> '+bench)
    tip = None
    for clave in sorted(TESTS.keys()) :
        archivo = contenedor_de_datos+'/'+TESTS[clave]+'/'+bench+sufijo

        dict_general[clave] = contenedor()
        try:
            f = open(contenedor_de_datos+'/'+TESTS[clave]+'/condor_log/'+bench+'.err')
            simend = buscar_string(f, 'SimEnd')
            f.close()
            if 'ContextsFinished' == simend :
                if tip == None :
                    tip = leerNombreDatos(archivo)
                    print(tip.names)

                df = pd.DataFrame(np.loadtxt(archivo,comments='#', skiprows=1, delimiter = ' ', dtype=tip))

                dict_general[clave].df = df
        except Exception as e:
            print('Fallo al cargar el archivo -> '+archivo)
            print(e)
    return dict_general

def loadDictCompleto(sufijo, contenedor_de_datos, exp, tip=None):


    directorio_salida = contenedor_de_datos+'/'+exp+'_resumen'

    #TESTS = {'sin L1':EXPERIMENTO+'_sinL1','con L1':EXPERIMENTO+'_conL1'}
    TESTS = {'con L1':exp+'_conL1'}
    DIR_GRAFICOS = directorio_salida+'/graficos'



    # crear directorios
    if not os.path.exists(directorio_salida):
        os.mkdir(directorio_salida)
    if not os.path.exists(directorio_salida+'/tablas'):
        os.mkdir(directorio_salida+'/tablas')
    if not os.path.exists(directorio_salida+'/graficos'):
        os.mkdir(directorio_salida+'/graficos')

    dict_general = dict()

    for bench in BENCHMARKS :
        dict_general[bench] = dict()

        print('cargando -> '+bench)

        for clave in sorted(TESTS.keys()) :
            archivo = contenedor_de_datos+'/'+TESTS[clave]+'/'+bench+sufijo

            dict_general[bench][clave] = contenedor()
            try:
                f = open(contenedor_de_datos+'/'+TESTS[clave]+'/condor_log/'+bench+'.err')
                simend = buscar_string(f, 'SimEnd')
                f.close()
                if 'ContextsFinished' == simend :
                    if tip == None :
                        tip = leerNombreDatos(archivo)
                        print(tip.names)

                    #df = pd.read_table(archivo)
                    df = pd.DataFrame(np.loadtxt(archivo,comments='#', skiprows=1, delimiter = ' ', dtype=tip))
                    #df = df.groupby( lambda x :  x // (np.ceil(df.shape[0]/30))).mean()
                    #dict_general[bench][clave] = ajustarResolucionPorTamanyo(df, 50)
                    #dict_general[bench][clave] = ajustarResolucion(df, 100)
                    dict_general[bench][clave].df = df
                    #dict_general[bench][clave].lista = loadDatosSueltos(archivo, dict_general[bench][clave].df)
            except Exception as e:
                print('Fallo al cargar el archivo -> '+archivo)
                print(e)
    return dict_general

def loadDatosSueltos(dict_c, dict_i):


    col= ['benchmark','test','estado','acceso gpu','coalesces gpu','Loads L1','coalesces L1','Loads L2','coalesces L2','ciclos','Macro IPC','IPC','latencia mem CU','hrL1','mpkiL1','evictions L2','evictions Sharers L2'''','latencia red L1-L2','latencia red L2-MM','blk compartidos','replicas''']
    df2 = pd.DataFrame(columns=col)
    for bench in BENCHMARKS :
        tabla = []
        for clave in sorted(TESTS.keys()) :
            lista = []
            finishStatus = 'NO_FINISHED'
            try:
                # test
                lista.append(bench)
                lista.append(clave)

                f = open(contenedor_de_datos+'/'+TESTS[clave]+'/condor_log/'+bench+'.err')
                finishStatus = buscar_string(f, 'SimEnd')
                if finishStatus == '' :
                    finishStatus = 'NO_FINISHED'
                lista.append(finishStatus)
                f.close()

                df = dict_i[bench][clave].df.astype('float')

                #acceso gpu
                lista.append(df['accesos gpu'].sum())

                #coalesced gpu
                lista.append(df['Coalesces gpu'].sum())


                # Loads L1
                f = open(contenedor_de_datos+'/'+TESTS[clave]+'/'+bench+'-mem-report')
                #lista.append(buscar_y_acumular(f,'[ l1','fffffff','Loads'))
                lista.append(df['accesos L1'].sum())
                f.close()

                #coalesced L1
                lista.append(df['Coalesces L1'].sum())

                #Loads desde L1 a L2
                lista.append(df['accesos L2'].sum())

                #coalesced L2
                lista.append(df['Coalesces L2'].sum())



                # ciclos
                f = open(contenedor_de_datos+'/'+TESTS[clave]+'/'+bench+'-si-report')
                ciclo_temp  = buscar_valor(f,'Cycles')
                lista.append(ciclo_temp)
                f.close()

                # Macro IPC
                f = open(contenedor_de_datos+'/'+TESTS[clave]+'/'+bench+'-si-report')
                instruciones = buscar_valor(f,'Instructions')
                lista.append(instruciones/ float(ciclo_temp))
                f.close()

                # IPC
                lista.append(df['total intervalo'].sum()/ float(ciclo_temp))

                # latencia CU mem
                lista.append(df['lat loads gpu'].sum()/ df['num loads gpu'].sum())

                # HR
                lista.append(df['hits L1'].sum() / df['efectivos L1'].sum())


                # MPKI
                lista.append(df['misses L1'].mean()/10)


                # Evictions en L2
                f = open(contenedor_de_datos+'/'+TESTS[clave]+'/'+bench+'-mem-report')
                lista.append(buscar_y_acumular(f,'[ l2','[ l1','Evictions'))
                f.close()

                # Evitions with sharers
                f = open(contenedor_de_datos+'/'+TESTS[clave]+'/'+bench+'-mem-report')
                lista.append(buscar_y_acumular(f,'[ l2','[ l1','EvictionsWithSharers'))
                f.close()

                # latencias red L1-L2 L2-MM
                '''paq = dict_c[bench][clave].df['paquetes L1-L2'].sum()

                if paq > 0 :
                    lista.append((dict_c[bench][clave].df['lat L1-L2'].sum()/8)/ paq)
                else:
                    lista.append(0)


                paq = dict_c[bench][clave].df['paquetes L2-MM'].sum()
                if paq > 0 :
                    lista.append((dict_c[bench][clave].df['lat L2-MM'].sum()/8)/ paq)
                else:
                    lista.append(0)


                #bloques compartidos y replicas

                lista.append(dict_c[bench][clave].df['blk compartidos'].mean())
                lista.append(dict_c[bench][clave].df['blk replicas'].mean())
                '''


                '''

                lista.append(stats.nanmean(df['latencia'].values))


                f = open(DIRECTORIO_RAIZ+'/'+j+'/'+i+'-si-report')
                instruciones = buscar_valor(f,'Instructions')
                lista.append(instruciones/ float(ciclo_temp))
                f.close()

                f = open(DIRECTORIO_RAIZ+'/'+j+'/'+i+'-mem-report')
                lista.append(buscar_y_acumular(f,'[ l2','[ l1','Evictions'))
                f.close()

                f = open(DIRECTORIO_RAIZ+'/'+j+'/'+i+'-mem-report')
                lista.append(buscar_y_acumular(f,'[ l2','[ l1','EvictionsWithSharers'))
                f.close()

                f = open(DIRECTORIO_RAIZ+'/'+j+'/'+i+'-mem-report')
                lista.append(buscar_y_acumular(f,'[ l2','[ l1','EvictionsSharersInvalidation'))
                f.close()
                if str(j).find('sinL1') == -1 :

                    lista.append(stats.nanmean(df['hr_loads_L2'].values))

                    lista.append(stats.nanmean(df['hr_loads_L1'].values))

                else:

                    lista.append(stats.nanmean(df['hr_loads_L1'].values))

                    lista.append(0)

                f = open(DIRECTORIO_RAIZ+'/'+j+'/'+i+'-mem-report')
                lista.append(buscar_y_acumular(f,'[ l1','fffffff','Loads'))
                f.close()

                f = open(DIRECTORIO_RAIZ+'/'+j+'/'+i+'-mem-report')
                lista.append(buscar_y_acumular(f,'[ l1','fffffff','CoalescedRead'))
                f.close()

                f = open(DIRECTORIO_RAIZ+'/'+j+'/'+i+'-mem-report')
                lista.append(buscar_y_acumular(f,'[ l2','[ l1','Loads'))
                f.close()

                if str(j).find('sinL1') == -1 :
                    lista.append(df.sum(0)['Coalesces L2'])
                else:
                    f = open(DIRECTORIO_RAIZ+'/'+j+'/'+i+'-mem-report')
                    lista.append(buscar_y_acumular(f,'[ l2','[ l1','CoalescedRead'))
                    f.close()

                   '''
            except Exception as e:
                print('problemas de lectura en el test: '+bench+' --> '+clave)
                print(e)
                lista = [bench,clave,finishStatus,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

            tabla.append(lista)

        df = pd.DataFrame(tabla, columns=col)

        df2 = df2.append(df)
    df2.set_index(['benchmark','test'],inplace=True)

    df2.to_excel(directorio_salida+'/'+EXPERIMENTO+'.xlsx',engine='xlsxwriter')

def ajustarResolucion(df, resolucion):

    dato = contenedor()
    dato.df = df
    try:
        tamanyoGrupo = np.ceil(df.shape[0]/resolucion)
        dato.sum = df.groupby( lambda x :  x // tamanyoGrupo).sum()
        dato.media = df.groupby( lambda x :  x // tamanyoGrupo).mean()
        #dato.media = df.groupby(funcionmagica(x,df)).mean()
        #return dato
    except Exception as e:
        print('exception en ajustarResolucion()')
        print(e)

    return dato

def ajustarResolucionPorTamanyo(df, tamanyoGrupo):

    dato = contenedor()
    dato.df = df
    try:
        dato.sum = df.groupby( lambda x :  x // tamanyoGrupo).sum()
        dato.media = df.groupby( lambda x :  x // tamanyoGrupo).mean()

    except Exception as e:
        print('exception en ajustarResolucioPorTamanyo()')
        print(e)

    return dato

def funcionmagica(x,df):
    tamanyoGrupo = np.ceil(df.shape[0]/resolucion)
    resolucion = 100
    if x > (df.shape[0] - (((tamanyoGrupo * resolucion) - df.shape[0]) * (tamanyoGrupo - 1))):
        return x // (tamanyGrupo - 1)
    else:
        return x // tamanyoGrupo

def leerNombreDatos(nombreArchivo):
    f = open(nombreArchivo)
    linea = f.readline()
    f.close()
    lista = []
    for i in linea.split(' '):
        #lista.append((i.strip(' \n\t\r').replace('_',' '),np.int64))
        lista.append((i.strip(' \n\t\r').replace('_',' '),np.float))

    return np.dtype(lista)

def tablas_access_list(nombreArchivo):


    if not os.path.exists(nombreArchivo):
        os.mkdir(nombreArchivo)

    for bench in BENCHMARKS :

        f, t= plt.subplots(1,3)
        f.set_size_inches(15, 8)
        f.set_dpi(100)
       # t[0][0].set_title('write access list')
       # t[0][1].set_title('access list')
        try:
            for prueba in ['08-05_vi8192_conL1','08-05_nmoesi8192_conL1']:

                archivo = contenedor_de_datos+'/'+prueba+'/'+bench+'-fran_ipc'
                file = open(contenedor_de_datos+'/'+prueba+'/condor_log/'+bench+'.err')
                simend = buscar_string(file, 'SimEnd')
                file.close()
                if 'ContextsFinished' == simend :
                    tip = leerNombreDatos(archivo)
                    print(tip.names)

                    df = pd.DataFrame(np.loadtxt(archivo,comments='#', skiprows=1, delimiter = ' ', dtype=tip))
                    #df = ajustarResolucionPorTamanyo(df, 10).df

                    dato = pd.DataFrame({prueba : df['write access list count']})
                    dato.plot(ax=t[0])

                    dato = pd.DataFrame({prueba : df['access list count']})
                    dato.plot(ax=t[1])

                    dato = pd.DataFrame({prueba : df['nc write access list count']})
                    dato.plot(ax=t[2])



            t[0].set_ylim(bottom = 0)
            t[0].set_ylabel('write en cola')
            t[0].set_xlabel('Instrucciones ejecutadas')

            t[1].set_ylim(bottom = 0)
            t[1].set_ylabel('accesos en cola')
            t[1].set_xlabel('Instrucciones ejecutadas')

            t[2].set_ylim(bottom = 0)
            t[2].set_ylabel('NC write en cola')
            t[2].set_xlabel('Instrucciones ejecutadas')


            f.suptitle(bench, fontsize=25)
            f.savefig(nombreArchivo+'/'+bench+'acces_list')

        except IOError as e:
            print('Fallo tablas_access_list en el test:')
            print(e)
        except Exception as e:
            print('Fallo tablas_access_list en el test: '+bench)
            print(e)
        t[0].cla()
        t[1].cla()
        plt.close(f)
    return

if __name__ == '__main__':
    # Create the queue and thread pool.
    start = time.time()


    '''font = {'family' : 'normal',
        'weight' : 'bold',
        'size'   : 16}

    mpl.rc('font', **font)'''

    #from mpltools import style
    #from mpltools import layout

    #style.use('ggplot')
    mpl.rcParams.update({'font.size': 16})

    #plt.rcParams['figure.autolayout'] = True

    '''
    tipos_instrucciones = np.dtype([('mshr L1',np.int64),('mshr L2',np.int64),('entradas bloqueadas L1',np.int64),('entradas bloqueadas L2',np.int64),('Coalesces L1',np.int64),('Coalesces L2',np.int64),('accesos L1',np.int64),('accesos L2',np.int64),('efectivos L1',np.int64),('efectivos L2',np.int64),('misses L1',np.int64),('misses L2',np.int64),('hits L1',np.int64),('hits L2',np.int64),('Cmisses L1',np.int64),('Cmisses L2',np.int64),('Chits L1',np.int64),('Chits L2',np.int64),('lat L1-L2',np.int64),('paquetes L1-L2',np.int64),('lat L2-MM',np.int64),('paquetes L2-MM',np.int64),('lat loads gpu',np.int64),('num loads gpu',np.int64),('lat loads mem',np.int64),('num loads mem',np.int64),('i_scalar',np.int64),('i_simd',np.int64),('mi_simd',np.int64),('i_s_mem',np.int64),('i_v_mem',np.int64),('mi_v_mem',np.int64),('i_branch',np.int64),('i_lds',np.int64),('mi_lds',np.int64),('total intervalo',np.int64),('total global',np.int64),('ciclos intervalo',np.int64),('ciclos totales',np.int64)])

    tipos_ciclos = np.dtype([('entradas bloqueadas L1(borrar)',np.int64),('entradas bloqueadas L2(borrar)',np.int64),('lat loads',np.int64),('num loads',np.int64),('Coalesces L1',np.int64),('accesos L1',np.int64),('hits L1',np.int64),('invalidations L1',np.int64),('Coalesces L2',np.int64),('accesos L2',np.int64),('hits L2',np.int64),('invalidations L2',np.int64),('busy in L1-L2',np.int64),('busy out L1-L2',np.int64),('busy in L2-MM',np.int64),('busy out L2-MM',np.int64),('lat L1-L2',np.int64),('paquetes L1-L2',np.int64),('lat L2-MM',np.int64),('paquetes L2-MM',np.int64),('blk compartidos',np.int64),('blk replicas',np.int64),('entradas bloqueadas L1',np.int64),('entradas bloqueadas L2',np.int64),('ciclos intervalo',np.int64),('ciclos totales',np.int64)])
    '''

    tipos_instrucciones = np.dtype([('access_list_count',np.int64),('mshr L1',np.int64),('mshr L2',np.int64),('entradas bloqueadas L1',np.int64),('entradas bloqueadas L2',np.int64),('Coalesces gpu',np.int64),('Coalesces L1',np.int64),('Coalesces L2',np.int64),('accesos gpu',np.int64),('accesos L1',np.int64),('accesos L2',np.int64),('efectivos L1',np.int64),('efectivos L2',np.int64),('misses L1',np.int64),('misses L2',np.int64),('hits L1',np.int64),('hits L2',np.int64),('Cmisses L1',np.int64),('Cmisses L2',np.int64),('Chits L1',np.int64),('Chits L2',np.int64),('lat L1-L2',np.int64),('paquetes L1-L2',np.int64),('lat L2-MM',np.int64),('paquetes L2-MM',np.int64),('lat loads gpu',np.int64),('num loads gpu',np.int64),('lat loads mem',np.int64),('num loads mem',np.int64),('i_scalar',np.int64),('i_simd',np.int64),('mi_simd',np.int64),('i_s_mem',np.int64),('i_v_mem',np.int64),('mi_v_mem',np.int64),('i_branch',np.int64),('i_lds',np.int64),('mi_lds',np.int64),('total intervalo',np.int64),('total global',np.int64),('ciclos intervalo',np.int64),('ciclos totales',np.int64)])

    # variables de los test

    nombre_resumen = ['01-28_mshr16_128L2','01-28_mshr32_128L2' ,'01-28_mshr64_128L2','01-28_mshr128_128L2','01-28_mshr256_128L2','01-28_mshr16_512L2','01-28_mshr32_512L2' ,'01-28_mshr64_512L2','01-28_mshr128_512L2','01-28_mshr256_512L2']


    #nombre_resumen = ['01-22_mshr_16','01-22_mshr_32','01-22_mshr_64','01-22_mshr_128','01-22_mshr_256','01-23_mshr_1024']

    #nombre_resumen = ['01-12_prueba_scalar_256','01-12_prueba_local_memory','01-12_mshr_32','01-06_test32']
    #nombre_resumen = ['01-12_control_mshr_basico','01-12_control_mshr_reset','01-12_control_mshr_intevalor_dinamico','01-12_control_mshr_intevalor_dinamico_reset','01-12_prueba_scalar_256','01-12_prueba_local_memory','01-12_mshr_32','01-06_test32']

    #nombre_resumen = ['12-04_5CU_mshr_16','12-04_5CU_mshr_32','12-04_5CU_mshr_256','12-03_pruebamshronmiss','12-04_5CU_mshr_holdonmiss','12-07_5CU_mshr_32_simd_idle']
    #,'11-25_mshr1_latdim_reset','11-25_mshr1_reset','11-25_mshr1_latdim']
    #nombre_resumen = ['11-17_mshr-colas-16','11-17_mshr-colas-32','11-17_mshr-colas-256','11-18_mshr1-latdim-256','11-18_mshr1-latdim-16','11-18_mshr1-latdim-16']
    #nombre_resumen = ['10-06_mshr16-32VIEJO','10-06_mshr32-64VIEJO','10-06_mshr1024-8192VIEJO','10-22_mshr_opc_500000','10-22_mshr_opc2','10-22_mshr_opc2_500000']
    #nombre_resumen = ['10-06_mshr16-32VIEJO','10-06_mshr32-64VIEJO','10-06_mshr1024-8192VIEJO','11-09_mshr1-32-64_latdim','11-09_mshr1-32-64_reset','11-09_mshr1-32-64_reset-latdim']
    #nombre_resumen = ['10-06_mshr16-32VIEJO','10-06_mshr32-64VIEJO','10-06_mshr1024-8192VIEJO','11-06_mshr1-32-64_latDim','11-06_mshr1-32-64_reset','11-07_mshr1-32-64_reset-latdim']

    #nombre_resumen =['10-01_mshrL2-8','10-01_mshrL2-32','10-01_mshrL2-128','10-01_mshrL2-512','10-01_mshrL2-2048']
    #nombre_resumen =['09-26_test']
    contenedor_de_datos = '/nfs/gap/fracanma/benchmark/resultados'

    dict_por_instrucciones = {}

    # columnas datos continuos
    columnas = ['latencia','ciclos','evictions','evictions con sharers','Invalidations','HitRatio L2','HitRatio L1','loads']

    # columnas datos sueltos
    datos = ['latencia_red_l1-l2','latencia_red_l2-mm','compartidos desde l2','replicas en l1','latencia','ciclos','IPC','evictions','evictions con sharers','Invalidations','HitRatio L2','HitRatio L1','loads L1','Coalesced L1','loads L2','coalesce L2']


    #benchmarks_amd = ['BlackScholes','FloydWarshall','FastWalshTransform','MatrixMultiplication','MersenneTwister','RadixSort','SimpleConvolution']

    #benchmarks_amd = ['BinarySearch','BinomialOption','BlackScholes','DCT','DwtHaar1D','FastWalshTransform','FloydWarshall','MatrixMultiplication','MatrixTranspose','MersenneTwister','QuasiRandomSequence','RadixSort','RecursiveGaussian','Reduction','ScanLargeArrays','SimpleConvolution']
    benchmarks_amd = ['BlackScholes','FastWalshTransform','FloydWarshall','MatrixMultiplication','MersenneTwister']
    benchmarks_rodinia = ['backprop','bfs','b+tree','gaussian','kmeans','lud','streamcluster']

    BENCHMARKS = benchmarks_amd

    directorio_salida = contenedor_de_datos+'/'+nombre_resumen[0]+'_resumen'
    DIR_GRAFICOS = directorio_salida+'/graficos'

    args = []
    for EXPERIMENTO in nombre_resumen:
        args.append(('-fran_ipc', contenedor_de_datos,EXPERIMENTO))

    #prueba

    pool = multiprocessing.Pool(processes=4)
    resultados_temp = []
    pool_result = []
    for EXPERIMENTO in nombre_resumen:
        args = []


        directorio_salida = contenedor_de_datos+'/'+EXPERIMENTO+'_resumen'
        DIR_GRAFICOS = directorio_salida+'/graficos'

        # crear directorios
        if not os.path.exists(directorio_salida):
            os.mkdir(directorio_salida)
        if not os.path.exists(directorio_salida+'/tablas'):
            os.mkdir(directorio_salida+'/tablas')
        if not os.path.exists(directorio_salida+'/graficos'):
            os.mkdir(directorio_salida+'/graficos')

        for bench in BENCHMARKS:
            args.append(('-fran_ipc', contenedor_de_datos,EXPERIMENTO,bench))

        pool_result.append(pool.starmap_async(loadDictCompletomultiprocesses2, args))

    for r in pool_result:
        aux = r.get()
        pprint.pprint(aux)
        resultados_temp.append( dict(zip(BENCHMARKS,aux)))


        # leer nombre de las columnas


    #dict_por_instrucciones[EXPERIMENTO] = loadDictCompleto('-fran_ipc',directorio_salida, TESTS)
    #dict_por_ciclos = loadDictCompleto('-fran_general')
    dict_por_ciclos = 1
    #loadDatosSueltos(dict_por_ciclos, dict_por_instrucciones[EXPERIMENTO])

    #pool = MyPool()
    #resultados_temp = pool.starmap(loadDictCompletomultiprocesses, args)

    #pool = multiprocessing.Pool()
    #resultados_temp = pool.starmap(loadDictCompleto, args)


    print('lanzado 1')
    pool.close()
    pool.join()
    dict_por_instrucciones = dict(zip(nombre_resumen, resultados_temp ))


        #IPC(DIR_GRAFICOS+'/por_instrucciones/',dict_por_instrucciones)
        #dibujar4tablas(DIR_GRAFICOS+'/por_instrucciones/',dict_por_instrucciones[exp],exp)

        #dibujar4tablas2(DIR_GRAFICOS+'/por_instrucciones/',dict_por_instrucciones)
        #tablas_access_list(DIR_GRAFICOS+'/por_instrucciones/')
        #comparar_velocidad('/nfs/gap/fracanma/benchmark/resultados/prueba_resumen/grafico')fracanma/benchmark/resultados/prueba_resumen/grafico')
        #gc.collect()

    IPCmultitest(DIR_GRAFICOS+'/por_instrucciones/', dict_por_instrucciones)
    barras_opc(DIR_GRAFICOS, dict_por_instrucciones)
    analisis_stall(DIR_GRAFICOS, dict_por_instrucciones)
    benchXexp(DIR_GRAFICOS, dict_por_instrucciones)

    print('time:',time.time() - start)